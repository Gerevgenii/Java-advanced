# Java-advanced
This repository is based on the tasks I solved during the fourth semester during my studies at CT ITMO.

## Тесты к курсу «Технологии Java»

[Условия домашних заданий](https://www.kgeorgiy.info/courses/java-advanced/homeworks.html)

## Домашнее задание 1. Обход файлов
1. Разработайте класс Walk, осуществляющий подсчет хеш-сумм файлов.
   1. Формат запуска:
      java Walk <входной файл> <выходной файл>
   2. Входной файл содержит список файлов, которые требуется обойти. <br/>
   3. Выходной файл должен содержать по одной строке для каждого файла. Формат строки:
      <шестнадцатеричная хеш-сумма> <путь к файлу>
   4. Для подсчета хеш-суммы используйте алгоритм Дженкинса.
   5. Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы все нули.
   6. Кодировка входного и выходного файлов — UTF-8.
   7. Размеры файлов могут превышать размер оперативной памяти.
   8. Пример:

      | Входной файл | Выходной файл |
      | :---: | :---: |
      | samples/1 <br/>samples/12 <br/>samples/123 <br/>samples/1234 <br/>samples/1 <br/>samples/binary <br/>samples/no-such-file <br/> | 806b80c9 samples/1 <br/>7401b0b6 samples/12 <br/>29b8dfb0 samples/123 <br/>ad414afe samples/1234 <br/>806b80c9 samples/1 <br/>ef2a46bd samples/binary <br/>00000000 samples/no-such-file |

2. При выполнении задания следует обратить внимание на:
   - Дизайн и обработку исключений, диагностику ошибок.
   - Программа должна корректно завершаться даже в случае ошибки.
   - Корректная работа с вводом-выводом.
   - Отсутствие утечки ресурсов.
   - Возможность повторного использования кода.
3. Требования к оформлению задания.
   - Проверяется исходный код задания.
   - Весь код должен находиться в пакете info.kgeorgiy.ja.фамилия.walk.

> [!NOTE]
> Исходный код
> * простой вариант (`Walk`):
>   [тесты](modules/info.kgeorgiy.java.advanced.walk/info/kgeorgiy/java/advanced/walk/WalkTest.java)
>
>   Тестовый модуль: [info.kgeorgiy.java.advanced.walk](artifacts/info.kgeorgiy.java.advanced.walk.jar)
>   Для того, чтобы протестировать программу:
>   - Скачайте
>     - тесты
>       - [базовый модуль](artifacts/info.kgeorgiy.java.advanced.base.jar)
>       - [тестовый модуль](artifacts/info.kgeorgiy.java.advanced.walk.jar) (свой для каждого ДЗ)
>     - [библиотеки](lib)
>   - Откомпилируйте решение домашнего задания
>   - Протестируйте домашнее задание
>     - Текущая директория должна:
>       - содержать все скачанные `.jar` файлы;
>       - содержать скомпилированное решение;
>       - __не__ содержать скомпилированные самостоятельно тесты.
>     - Запустите тесты:
>       `java -cp . -p . -m <тестовый модуль> <вариант> <полное имя класса>`
>       - Пример для простого варианта ДЗ-1:
>       `java -cp . -p . -m info.kgeorgiy.java.advanced.walk Walk <полное имя класса>`

## Домашнее задание 2. Множество на массиве
1. Разработайте класс ArraySet, реализующий неизменяемое упорядоченное множество.
   - Класс ArraySet должен реализовывать интерфейс SortedSet (простой вариант) или NavigableSet (сложный вариант).
   - Все операции над множествами должны производиться с наилучшей асимптотической эффективностью.
2. При выполнении задания следует обратить внимание на:
   - Применение стандартных коллекций.
   - Избавление от повторяющегося кода.
   - Отсутствие Unchecked warnings при компиляции.
   - Отсутствие излишних подавленных unchecked warnings.

> [!NOTE]
> - Вариант (`SortedSet`):
>   [тесты](modules/info.kgeorgiy.java.advanced.arrayset/info/kgeorgiy/java/advanced/arrayset/SortedSetTest.java)
> - Тестовый модуль: [info.kgeorgiy.java.advanced.arrayset](artifacts/info.kgeorgiy.java.advanced.arrayset.jar)

## Домашнее задание 3. Студенты
1. Разработайте класс StudentDB, осуществляющий поиск по базе данных студентов.
   - Класс StudentDB должен реализовывать интерфейс StudentQuery (простой вариант) или GroupQuery (сложный вариант).
   - Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
2. При выполнении задания следует обратить внимание на:
   - применение лямбда-выражений и потоков;
   - избавление от повторяющегося кода.

> [!NOTE]
>  * Вариант (`StudentQuery`):
>   [интерфейс](modules/info.kgeorgiy.java.advanced.student/info/kgeorgiy/java/advanced/student/StudentQuery.java),
>   [тесты](modules/info.kgeorgiy.java.advanced.student/info/kgeorgiy/java/advanced/student/StudentQueryTest.java)

## Домашнее задание 4. Implementor
1. Реализуйте класс Implementor, генерирующий реализации классов и интерфейсов.
   - Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
   - В результате работы должен быть сгенерирован java-код класса с суффиксом Impl, расширяющий (реализующий) указанный класс (интерфейс).
   - Сгенерированный класс должен компилироваться без ошибок.
   - Сгенерированный класс не должен быть абстрактным.
   - Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2. Implementor должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.

> [!NOTE]
> - Класс `Implementor` должен реализовывать интерфейс
>   [Impler](modules/info.kgeorgiy.java.advanced.implementor/info/kgeorgiy/java/advanced/implementor/Impler.java).
> - Вариант (`interface`): 
>   [тесты](modules/info.kgeorgiy.java.advanced.implementor/info/kgeorgiy/java/advanced/implementor/InterfaceImplementorTest.java)
> - Тестовый модуль: [info.kgeorgiy.java.advanced.implementor](artifacts/info.kgeorgiy.java.advanced.implementor.jar)

## Домашнее задание 5. Jar Implementor
Это домашнее задание связано с предыдущим и будет приниматься только с ним. Предыдущее домашнее задание отдельно сдать будет нельзя.

1. Создайте .jar-файл, содержащий скомпилированный Implementor и сопутствующие классы.
   - Созданный .jar-файл должен запускаться командой java -jar.
   - Запускаемый .jar-файл должен принимать те же аргументы командной строки, что и класс Implementor.
2. Модифицируйте Implementor так, чтобы при запуске с аргументами -jar имя-класса файл.jar он генерировал .jar-файл с реализацией соответствующего класса (интерфейса).
3. Вы можете создавать файлы и директории в текущем каталоге, но не за его пределами.
4. Для проверки, кроме исходного кода так же должны быть представлены:
   - скрипт для создания запускаемого .jar-файла, в том числе исходный код манифеста;
   - запускаемый .jar-файл.

> [!NOTE]
> 1. Класс `Implementor` должен дополнительно реализовывать интерфейс
>    [JarImpler](modules/info.kgeorgiy.java.advanced.implementor/info/kgeorgiy/java/advanced/implementor/JarImpler.java).
> 2. Скрипты, `MANIFEST.MF` и `.jar-файл` должны находиться в каталоге `scripts` в корне репозитория. 
> 3. Скомпилированный Javadoc должен находиться в каталоге `javadoc` в корне репозитория.
> 4. В скриптах вы можете рассчитывать на то, что репозиторий курса лежит рядом с вашим репозиторием в каталоге `java-advanced-2024`.
> - Вариант (`jar-interface`):
>   [тесты](modules/info.kgeorgiy.java.advanced.implementor/info/kgeorgiy/java/advanced/implementor/InterfaceJarImplementorTest.java)
> - Тестовый модуль: [info.kgeorgiy.java.advanced.implementor](artifacts/info.kgeorgiy.java.advanced.implementor.jar)

## Домашнее задание 6. Javadoc
> [!WARNING]
> Это домашнее задание связано с двумя предыдущими и будет приниматься только с ними. Предыдущие домашнее задание отдельно сдать будет нельзя.

1. Документируйте класс Implementor и сопутствующие классы с применением Javadoc.
   - Должны быть документированы все классы и все члены классов, в том числе private.
   - Документация должна генерироваться без предупреждений.
   - Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки и модуля info.kgeorgiy.java.advanced.implementor.
2. Для проверки, кроме исходного кода так же должны быть представлены:
   - скрипт для генерации документации;
   - сгенерированная документация.

> [!NOTE]
> Заметки в задании 5

## Домашнее задание 7. Итеративный параллелизм
1. Реализуйте класс IterativeParallelism, который будет обрабатывать списки в несколько потоков.
2. В варианте должны быть реализованы следующие методы:
   - minimum(threads, list, comparator) — первый минимум;
   - maximum(threads, list, comparator) — первый максимум;
   - all(threads, list, predicate) — проверка, что все элементы списка, удовлетворяют предикату;
   - any(threads, list, predicate) — проверка, что существует элемент списка, удовлетворяющий предикату.
   - count(threads, list, predicate) — подсчёт числа элементов списка, удовлетворяющих предикату.
3. Во все функции передается параметр threads — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков относительно мало.
4. Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
5. При выполнении задания нельзя использовать Concurrency Utilities и Parallel Streams.

> [!NOTE]
> - Вариант (`scalar`):
>   - Класс должен реализовывать интерфейс
>     [ScalarIP](modules/info.kgeorgiy.java.advanced.iterative/info/kgeorgiy/java/advanced/iterative/ScalarIP.java).
>   - [тесты](modules/info.kgeorgiy.java.advanced.iterative/info/kgeorgiy/java/advanced/iterative/ScalarIPTest.java)
> - Модификация (`new-scalar`):
>   - Класс должен реализовывать интерфейс
>     [NewScalarIP](modules/info.kgeorgiy.java.advanced.iterative/info/kgeorgiy/java/advanced/iterative/NewScalarIP.java).
>   - [тесты](modules/info.kgeorgiy.java.advanced.iterative/info/kgeorgiy/java/advanced/iterative/NewScalarIPTest.java)
> - Тестовый модуль: [info.kgeorgiy.java.advanced.iterative](artifacts/info.kgeorgiy.java.advanced.iterative.jar)

## Домашнее задание 8. Параллельный запуск
1. Напишите класс ParallelMapperImpl, реализующий интерфейс ParallelMapper.
   ```
   public interface ParallelMapper extends AutoCloseable {
       <T, R> List<R> map(
           Function<? super T, ? extends R> f,
           List<? extends T> args
       ) throws InterruptedException;
   
       @Override
       void close();
   }
   ```
   - Метод map должен параллельно вычислять функцию f на каждом из указанных аргументов (args).
   - Метод close должен останавливать все рабочие потоки.
   - Конструктор ParallelMapperImpl(int threads) создает threads рабочих потоков, которые должны быть использованы для распараллеливания.
   - К одному ParallelMapperImpl могут одновременно обращаться несколько клиентов.
   - Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
   - В реализации не должно быть активных ожиданий.
2. Доработайте класс IterativeParallelism так, чтобы он мог использовать ParallelMapper.
   - Добавьте конструктор IterativeParallelism(ParallelMapper).
   - Методы класса должны делить работу на threads фрагментов и исполнять их при помощи ParallelMapper.
   - При наличии ParallelMapper сам IterativeParallelism новые потоки создавать не должен.
   - Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один ParallelMapper.
3. При выполнении задания всё ещё нельзя использовать Concurrency Utilities и Parallel Streams.

> [!NOTE]
> - Вариант (`scalar`):
>   [тесты](modules/info.kgeorgiy.java.advanced.mapper/info/kgeorgiy/java/advanced/mapper/ScalarMapperTest.java)
> - Модификация (`new-scalar`):
>   - Класс `IterativeParallelism` должен реализовывать интерфейс
>     [NewScalarIP](modules/info.kgeorgiy.java.advanced.iterative/info/kgeorgiy/java/advanced/iterative/NewScalarIP.java).
>   - [Тесты](modules/info.kgeorgiy.java.advanced.mapper/info/kgeorgiy/java/advanced/mapper/NewScalarMapperTest.java)
> - Тестовый модуль: [info.kgeorgiy.java.advanced.mapper](artifacts/info.kgeorgiy.java.advanced.mapper.jar)

## Домашнее задание 9. Web Crawler
1. Напишите потокобезопасный класс WebCrawler, который будет рекурсивно обходить сайты.
   1. Класс WebCrawler должен иметь конструктор
      public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
      - downloader позволяет скачивать страницы и извлекать из них ссылки;
      - downloaders — максимальное число одновременно загружаемых страниц;
      - extractors — максимальное число страниц, из которых одновременно извлекаются ссылки;
      - perHost — максимальное число страниц, одновременно загружаемых c одного хоста. Для определения хоста следует использовать метод getHost класса URLUtils из тестов.
   2. Класс WebCrawler должен реализовывать интерфейс Crawler
      ```
      public interface Crawler extends AutoCloseable {
          Result download(String url, int depth);
      
          void close();
      }
      ```
      - Метод download должен рекурсивно обходить страницы, начиная с указанного URL, на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается, и так далее.
      - Метод download может вызываться параллельно в нескольких потоках.
      - Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
      - Для распараллеливания разрешается создать до downloaders + extractors вспомогательных потоков.
      - Повторно загружать и/или извлекать ссылки из одной и той же страницы в рамках одного обхода (download) запрещается.
      - Метод close должен завершать все вспомогательные потоки.
   3. Для загрузки страниц должен применяться Downloader, передаваемый первым аргументом конструктора.
      ```
      public interface Downloader {
          public Document download(final String url) throws IOException;
      }
      ```
      - Метод download загружает документ по его адресу (URL).
      - Документ позволяет получить ссылки по загруженной странице:
        ```
        public interface Document {
            List<String> extractLinks() throws IOException;
        }
        ```
        Ссылки, возвращаемые документом, являются абсолютными и имеют схему http или https.
   4. Должен быть реализован метод main, позволяющий запустить обход из командной строки
      - Командная строка
        WebCrawler url [depth [downloads [extractors [perHost]]]]
      - Для загрузки страниц требуется использовать реализацию CachingDownloader из тестов.
2. Не требуется учитывать ограничения на число одновременных закачек с одного хоста (perHost >= downloaders).
3. Задание подразумевает активное использование Concurrency Utilities, в частности, в решении не должно быть «велосипедов», аналогичных/легко сводящихся к классам из Concurrency Utilities.

> [!NOTE]
> Тесты используют только внутренние данные и ничего не скачивают из интернета.
> - Вариант (`easy`):
>   [тесты](modules/info.kgeorgiy.java.advanced.crawler/info/kgeorgiy/java/advanced/crawler/EasyCrawlerTest.java)
> - Модификация (`new-easy`):
>   [интерфейс](modules/info.kgeorgiy.java.advanced.crawler/info/kgeorgiy/java/advanced/crawler/NewCrawler.java),
>   [тесты](modules/info.kgeorgiy.java.advanced.crawler/info/kgeorgiy/java/advanced/crawler/NewEasyCrawlerTest.java)

## Домашнее задание 10. HelloUDP
1. Реализуйте клиент и сервер, взаимодействующие по UDP.
2. Класс HelloUDPClient должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
   - Аргументы командной строки:
     1. имя или ip-адрес компьютера, на котором запущен сервер;
     2. номер порта, на который отсылать запросы;
     3. префикс запросов (строка);
     4. число параллельных потоков запросов;
     5. число запросов в каждом потоке.
   - Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заново.
   - Запросы должны формироваться по схеме <префикс запросов><номер потока>_<номер запроса в потоке>.
3. Класс HelloUDPServer должен принимать задания, отсылаемые классом HelloUDPClient и отвечать на них.
   - Аргументы командной строки:
     1. номер порта, по которому будут приниматься запросы;
     2. число рабочих потоков, которые будут обрабатывать запросы.
   - Ответом на запрос должно быть Hello, <текст запроса>.
   - Несмотря на то, что текущий способ получения ответа по запросу очень прост, сервер должен быть рассчитан на ситуацию, когда этот процесс может требовать много ресурсов и времени.
   - Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.

> [!NOTE]
> 1. Интерфейсы
>    - `HelloUDPClient` должен реализовывать интерфейс
>      [HelloClient](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/HelloClient.java)
>    - `HelloUDPServer` должен реализовывать интерфейс
>      [HelloServer](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/HelloServer.java)
> 2. Тестирование
>    - Базовый вариант (`client` и `server`)
>    - Вариант (`new-client` и `new-server`)
>      `HelloUDPServer` должен реализовывать интерфейс
>      [NewHelloServer](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/NewHelloServer.java)

## Домашнее задание 11. Физические лица
1. Добавьте к банковскому приложению возможность работы с физическими лицами.
   1. У физического лица (Person) можно запросить имя, фамилию и номер паспорта.
   2. Удалённые физические лица (RemotePerson) должны передаваться при помощи удалённых объектов.
   3. Локальные физические лица (LocalPerson) должны передаваться при помощи механизма сериализации, и при последующем использовании не требовать связи с сервером.
   4. Должна быть возможность поиска физического лица по номеру паспорта, с выбором типа возвращаемого лица.
   5. Должна быть возможность создания записи о физическом лице по его данным.
   6. У физического лица может быть несколько счетов, к которым должен предоставляться доступ (через Person).
   7. Счёту физического лица с идентификатором subId должен соответствовать банковский счёт с id вида passport:subId.
   8. Изменения, производимые со счётом в банке (создание и изменение баланса), должны быть видны всем соответствующим RemotePerson, и только тем LocalPerson, которые были созданы после этого изменения.
   9. Изменения в счетах, производимые через RemotePerson, должны сразу применяться глобально, а производимые через LocalPerson – только локально для этого конкретного LocalPerson.
2. Реализуйте приложение, демонстрирующее работу с физическим лицами.
   1. Аргументы командной строки: имя, фамилия, номер паспорта физического лица, номер счёта, изменение суммы счёта.
   2. Если информация об указанном физическом лице отсутствует, то оно должно быть добавлено. В противном случае – должны быть проверены его данные.
   3. Если у физического лица отсутствует счёт с указанным номером, то он создается с нулевым балансом.
   4. После обновления суммы счёта новый баланс должен выводиться на консоль.
3. Напишите тесты, проверяющие вышеуказанное поведение как банка, так и приложения.
   - Для реализации тестов рекомендуется использовать JUnit (Tutorial). Множество примеров использования можно найти в тестах.
   - Если вы знакомы с другим тестовым фреймворком (например, TestNG), то можете использовать его.
   - Добавьте jar-файлы используемых библиотек в каталог lib вашего репозитория.
   - Нельзя использовать самописные фреймворки и тесты, запускаемые через main.
4. Приложения и тесты должны находится в пакете info.kgeorgiy.ja.*.bank и его подпакетах.

> [!NOTE]
> 1. Модификации
>    Без модификации.

## Домашнее задание 12. HelloNonblockingUDP
1. Реализуйте клиент и сервер, взаимодействующие по UDP, используя только неблокирующий ввод-вывод.
2. Класс HelloUDPNonblockingClient должен иметь функциональность аналогичную HelloUDPClient, но без создания новых потоков.
3. Класс HelloUDPNonblockingServer должен иметь функциональность аналогичную HelloUDPServer, но все операции с сокетом должны производиться в одном потоке.
4. В реализации не должно быть активных ожиданий, в том числе через Selector.
5. Обратите внимание на выделение общего кода старой и новой реализации.
6. Бонусный вариант. Клиент и сервер могут перед началом работы выделить O(число рабочих потоков) памяти. Выделять дополнительную память во время работы запрещено.

> [!NOTE]
> 1. Интерфейсы
>    - `HelloUDPNonblockingClient` должен реализовывать интерфейс
       [HelloClient](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/HelloClient.java)
>    - `HelloUDPNonblockingServer` должен реализовывать интерфейс
>      [HelloServer](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/HelloServer.java)
> 2. Тестирование
>    - Базовый вариант (`client` и `server`)
>    - Вариант (`new-client` и `new-server`)
>      `HelloUDPNonblockingServer` должен реализовывать интерфейс
>      [NewHelloServer](modules/info.kgeorgiy.java.advanced.hello/info/kgeorgiy/java/advanced/hello/NewHelloServer.java)
> 3. Тестовый модуль: [info.kgeorgiy.java.advanced.hello](artifacts/info.kgeorgiy.java.advanced.hello.jar)

## Домашнее задание 13. Статистика текста
1. Создайте приложение TextStatistics, анализирующее тексты на различных языках.
   1. Аргументы командной строки:
      - локаль текста,
      - локаль вывода,
      - файл с текстом,
      - файл отчета.
   2. Поддерживаемые локали текста: все локали, имеющиеся в системе.
   3. Поддерживаемые локали вывода: русская и английская.
   4. Файлы имеют кодировку UTF-8.
   5. Подсчет статистики должен вестись по следующим категориям:
      - предложения,
      - слова,
      - числа,
      - деньги,
      - даты.
   6. Для каждой категории должна собираться следующая статистика:
      - число вхождений,
      - число различных значений,
      - минимальное значение,
      - максимальное значение,
      - минимальная длина,
      - максимальная длина,
      - среднее значение/длина.
   7. Пример отчета:
      ```
      Анализируемый файл "input.txt".
      Сводная статистика
          Число предложений: 30.
          Число слов: 117.
          Число чисел: 37.
          Число сумм: 3.
          Число дат: 3.
      Статистика по предложениям
          Число предложений: 30 (30 различных).
          Минимальное предложение: "Анализируемый файл "input.txt".".
          Максимальное предложение: "Число чисел: 37.".
          Минимальная длина предложения: 13 ("Число дат: 3.").
          Максимальная длина предложения: 109 ("GK: если сюда поставить реальное предложение, то процесс не сойдётся").
          Средняя длина предложения: 37,333.
      Статистика по словам
          Число слов: 117 (48 различных).
          Минимальное слово: "GK".
          Максимальное слово: "языках".
          Минимальная длина слова: 1 ("с").
          Максимальная длина слова: 15 ("стабилизировать").
          Средняя длина слова: 6,641.
      Статистика по числам
          Число чисел: 37 (22 различных).
          Минимальное число: -12345,67.
          Максимальное число: 12345,67.
          Среднее число: 208,847.
      Статистика по суммам денег
          Число сумм: 3 (3 различных).
          Минимальная сумма: 100,00 ₽.
          Максимальная сумма: 345,67 ₽.
          Средняя сумма: 222,83 ₽.
      Статистика по датам
          Число дат: 3 (3 различных).
          Минимальная дата: 17 мая 2024 г..
          Максимальная дата: 30 мая 2024 г..
          Средняя дата: 23 мая 2024 г..
      ```
2. Вы можете рассчитывать на то, что весь текст помещается в память.
3. При выполнении задания следует обратить внимание на:
   1. Декомпозицию сообщений для локализации.
   2. Согласование сообщений по роду и числу.
4. Напишите тесты, проверяющие вышеуказанное поведение приложения.
   - Для реализации тестов рекомендуется использовать JUnit (Tutorial). Множество примеров использования можно найти в тестах.
   - Если вы знакомы с другим тестовым фреймворком (например, TestNG), то можете использовать его.
   - Нельзя использовать самописные фреймворки и тесты, запускаемые через main.
5. Приложение и тесты должны находится в пакете info.kgeorgiy.ja.*.i18n и его подпакетах.
